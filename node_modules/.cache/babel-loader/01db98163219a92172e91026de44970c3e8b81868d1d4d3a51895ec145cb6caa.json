{"ast":null,"code":"// @ts-check\n/**\n * @file\n * Helper plugin manages the cached state of the child compilation\n *\n * To optimize performance the child compilation is running asyncronously.\n * Therefore it needs to be started in the compiler.make phase and ends after\n * the compilation.afterCompile phase.\n *\n * To prevent bugs from blocked hooks there is no promise or event based api\n * for this plugin.\n *\n * Example usage:\n *\n * ```js\n    const childCompilerPlugin = new PersistentChildCompilerPlugin();\n    childCompilerPlugin.addEntry('./src/index.js');\n    compiler.hooks.afterCompile.tapAsync('MyPlugin', (compilation, callback) => {\n      console.log(childCompilerPlugin.getCompilationResult()['./src/index.js']));\n      return true;\n    });\n * ```\n */\n\n// Import types\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n/** @typedef {{hash: string, entry: any, content: string }} ChildCompilationResultEntry */\n/** @typedef {import(\"./file-watcher-api\").Snapshot} Snapshot */\n/** @typedef {{fileDependencies: string[], contextDependencies: string[], missingDependencies: string[]}} FileDependencies */\n/** @typedef {{\n  dependencies: FileDependencies,\n  compiledEntries: {[entryName: string]: ChildCompilationResultEntry}\n} | {\n  dependencies: FileDependencies,\n  error: Error\n}} ChildCompilationResult */\n'use strict';\n\nconst {\n  HtmlWebpackChildCompiler\n} = require('./child-compiler');\nconst fileWatcherApi = require('./file-watcher-api');\n\n/**\n * This plugin is a singleton for performance reasons.\n * To keep track if a plugin does already exist for the compiler they are cached\n * in this map\n * @type {WeakMap<WebpackCompiler, PersistentChildCompilerSingletonPlugin>}}\n */\nconst compilerMap = new WeakMap();\nclass CachedChildCompilation {\n  /**\n   * @param {WebpackCompiler} compiler\n   */\n  constructor(compiler) {\n    /**\n     * @private\n     * @type {WebpackCompiler}\n     */\n    this.compiler = compiler;\n    // Create a singleton instance for the compiler\n    // if there is none\n    if (compilerMap.has(compiler)) {\n      return;\n    }\n    const persistentChildCompilerSingletonPlugin = new PersistentChildCompilerSingletonPlugin();\n    compilerMap.set(compiler, persistentChildCompilerSingletonPlugin);\n    persistentChildCompilerSingletonPlugin.apply(compiler);\n  }\n\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {string} entry\n   */\n  addEntry(entry) {\n    const persistentChildCompilerSingletonPlugin = compilerMap.get(this.compiler);\n    if (!persistentChildCompilerSingletonPlugin) {\n      throw new Error('PersistentChildCompilerSingletonPlugin instance not found.');\n    }\n    persistentChildCompilerSingletonPlugin.addEntry(entry);\n  }\n  getCompilationResult() {\n    const persistentChildCompilerSingletonPlugin = compilerMap.get(this.compiler);\n    if (!persistentChildCompilerSingletonPlugin) {\n      throw new Error('PersistentChildCompilerSingletonPlugin instance not found.');\n    }\n    return persistentChildCompilerSingletonPlugin.getLatestResult();\n  }\n\n  /**\n   * Returns the result for the given entry\n   * @param {string} entry\n   * @returns {\n      | { mainCompilationHash: string, error: Error }\n      | { mainCompilationHash: string, compiledEntry: ChildCompilationResultEntry }\n    }\n   */\n  getCompilationEntryResult(entry) {\n    const latestResult = this.getCompilationResult();\n    const compilationResult = latestResult.compilationResult;\n    return 'error' in compilationResult ? {\n      mainCompilationHash: latestResult.mainCompilationHash,\n      error: compilationResult.error\n    } : {\n      mainCompilationHash: latestResult.mainCompilationHash,\n      compiledEntry: compilationResult.compiledEntries[entry]\n    };\n  }\n}\nclass PersistentChildCompilerSingletonPlugin {\n  constructor() {\n    /**\n     * @private\n     * @type {\n      | {\n        isCompiling: false,\n        isVerifyingCache: false,\n        entries: string[],\n        compiledEntries: string[],\n        mainCompilationHash: string,\n        compilationResult: ChildCompilationResult\n      }\n    | Readonly<{\n      isCompiling: false,\n      isVerifyingCache: true,\n      entries: string[],\n      previousEntries: string[],\n      previousResult: ChildCompilationResult\n    }>\n    | Readonly <{\n      isVerifyingCache: false,\n      isCompiling: true,\n      entries: string[],\n    }>\n    } the internal compilation state */\n    this.compilationState = {\n      isCompiling: false,\n      isVerifyingCache: false,\n      entries: [],\n      compiledEntries: [],\n      mainCompilationHash: 'initial',\n      compilationResult: {\n        dependencies: {\n          fileDependencies: [],\n          contextDependencies: [],\n          missingDependencies: []\n        },\n        compiledEntries: {}\n      }\n    };\n  }\n\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {WebpackCompiler} compiler\n   */\n  apply(compiler) {\n    /** @type Promise<ChildCompilationResult> */\n    let childCompilationResultPromise = Promise.resolve({\n      dependencies: {\n        fileDependencies: [],\n        contextDependencies: [],\n        missingDependencies: []\n      },\n      compiledEntries: {}\n    });\n    /**\n     * The main compilation hash which will only be updated\n     * if the childCompiler changes\n     */\n    let mainCompilationHashOfLastChildRecompile = '';\n    /** @typedef{Snapshot|undefined} */\n    let previousFileSystemSnapshot;\n    let compilationStartTime = new Date().getTime();\n    compiler.hooks.make.tapAsync('PersistentChildCompilerSingletonPlugin', (mainCompilation, callback) => {\n      if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n        return callback(new Error('Child compilation has already started'));\n      }\n\n      // Update the time to the current compile start time\n      compilationStartTime = new Date().getTime();\n\n      // The compilation starts - adding new templates is now not possible anymore\n      this.compilationState = {\n        isCompiling: false,\n        isVerifyingCache: true,\n        previousEntries: this.compilationState.compiledEntries,\n        previousResult: this.compilationState.compilationResult,\n        entries: this.compilationState.entries\n      };\n\n      // Validate cache:\n      const isCacheValidPromise = this.isCacheValid(previousFileSystemSnapshot, mainCompilation);\n      let cachedResult = childCompilationResultPromise;\n      childCompilationResultPromise = isCacheValidPromise.then(isCacheValid => {\n        // Reuse cache\n        if (isCacheValid) {\n          return cachedResult;\n        }\n        // Start the compilation\n        const compiledEntriesPromise = this.compileEntries(mainCompilation, this.compilationState.entries);\n        // Update snapshot as soon as we know the filedependencies\n        // this might possibly cause bugs if files were changed inbetween\n        // compilation start and snapshot creation\n        compiledEntriesPromise.then(childCompilationResult => {\n          return fileWatcherApi.createSnapshot(childCompilationResult.dependencies, mainCompilation, compilationStartTime);\n        }).then(snapshot => {\n          previousFileSystemSnapshot = snapshot;\n        });\n        return compiledEntriesPromise;\n      });\n\n      // Add files to compilation which needs to be watched:\n      mainCompilation.hooks.optimizeTree.tapAsync('PersistentChildCompilerSingletonPlugin', (chunks, modules, callback) => {\n        const handleCompilationDonePromise = childCompilationResultPromise.then(childCompilationResult => {\n          this.watchFiles(mainCompilation, childCompilationResult.dependencies);\n        });\n        handleCompilationDonePromise.then(() => callback(null, chunks, modules), callback);\n      });\n\n      // Store the final compilation once the main compilation hash is known\n      mainCompilation.hooks.additionalAssets.tapAsync('PersistentChildCompilerSingletonPlugin', callback => {\n        const didRecompilePromise = Promise.all([childCompilationResultPromise, cachedResult]).then(_ref => {\n          let [childCompilationResult, cachedResult] = _ref;\n          // Update if childCompilation changed\n          return cachedResult !== childCompilationResult;\n        });\n        const handleCompilationDonePromise = Promise.all([childCompilationResultPromise, didRecompilePromise]).then(_ref2 => {\n          let [childCompilationResult, didRecompile] = _ref2;\n          // Update hash and snapshot if childCompilation changed\n          if (didRecompile) {\n            mainCompilationHashOfLastChildRecompile = mainCompilation.hash;\n          }\n          this.compilationState = {\n            isCompiling: false,\n            isVerifyingCache: false,\n            entries: this.compilationState.entries,\n            compiledEntries: this.compilationState.entries,\n            compilationResult: childCompilationResult,\n            mainCompilationHash: mainCompilationHashOfLastChildRecompile\n          };\n        });\n        handleCompilationDonePromise.then(() => callback(null), callback);\n      });\n\n      // Continue compilation:\n      callback(null);\n    });\n  }\n\n  /**\n   * Add a new entry to the next compile run\n   * @param {string} entry\n   */\n  addEntry(entry) {\n    if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n      throw new Error('The child compiler has already started to compile. ' + \"Please add entries before the main compiler 'make' phase has started or \" + 'after the compilation is done.');\n    }\n    if (this.compilationState.entries.indexOf(entry) === -1) {\n      this.compilationState.entries = [...this.compilationState.entries, entry];\n    }\n  }\n  getLatestResult() {\n    if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n      throw new Error('The child compiler is not done compiling. ' + \"Please access the result after the compiler 'make' phase has started or \" + 'after the compilation is done.');\n    }\n    return {\n      mainCompilationHash: this.compilationState.mainCompilationHash,\n      compilationResult: this.compilationState.compilationResult\n    };\n  }\n\n  /**\n   * Verify that the cache is still valid\n   * @private\n   * @param {Snapshot | undefined} snapshot\n   * @param {WebpackCompilation} mainCompilation\n   * @returns {Promise<boolean>}\n   */\n  isCacheValid(snapshot, mainCompilation) {\n    if (!this.compilationState.isVerifyingCache) {\n      return Promise.reject(new Error('Cache validation can only be done right before the compilation starts'));\n    }\n    // If there are no entries we don't need a new child compilation\n    if (this.compilationState.entries.length === 0) {\n      return Promise.resolve(true);\n    }\n    // If there are new entries the cache is invalid\n    if (this.compilationState.entries !== this.compilationState.previousEntries) {\n      return Promise.resolve(false);\n    }\n    // Mark the cache as invalid if there is no snapshot\n    if (!snapshot) {\n      return Promise.resolve(false);\n    }\n    return fileWatcherApi.isSnapShotValid(snapshot, mainCompilation);\n  }\n\n  /**\n   * Start to compile all templates\n   *\n   * @private\n   * @param {WebpackCompilation} mainCompilation\n   * @param {string[]} entries\n   * @returns {Promise<ChildCompilationResult>}\n   */\n  compileEntries(mainCompilation, entries) {\n    const compiler = new HtmlWebpackChildCompiler(entries);\n    return compiler.compileTemplates(mainCompilation).then(result => {\n      return {\n        // The compiled sources to render the content\n        compiledEntries: result,\n        // The file dependencies to find out if a\n        // recompilation is required\n        dependencies: compiler.fileDependencies,\n        // The main compilation hash can be used to find out\n        // if this compilation was done during the current compilation\n        mainCompilationHash: mainCompilation.hash\n      };\n    }, error => ({\n      // The compiled sources to render the content\n      error,\n      // The file dependencies to find out if a\n      // recompilation is required\n      dependencies: compiler.fileDependencies,\n      // The main compilation hash can be used to find out\n      // if this compilation was done during the current compilation\n      mainCompilationHash: mainCompilation.hash\n    }));\n  }\n\n  /**\n   * @private\n   * @param {WebpackCompilation} mainCompilation\n   * @param {FileDependencies} files\n   */\n  watchFiles(mainCompilation, files) {\n    fileWatcherApi.watchFiles(mainCompilation, files);\n  }\n}\nmodule.exports = {\n  CachedChildCompilation\n};","map":{"version":3,"names":["HtmlWebpackChildCompiler","require","fileWatcherApi","compilerMap","WeakMap","CachedChildCompilation","constructor","compiler","has","persistentChildCompilerSingletonPlugin","PersistentChildCompilerSingletonPlugin","set","apply","addEntry","entry","get","Error","getCompilationResult","getLatestResult","getCompilationEntryResult","latestResult","compilationResult","mainCompilationHash","error","compiledEntry","compiledEntries","compilationState","isCompiling","isVerifyingCache","entries","dependencies","fileDependencies","contextDependencies","missingDependencies","childCompilationResultPromise","Promise","resolve","mainCompilationHashOfLastChildRecompile","previousFileSystemSnapshot","compilationStartTime","Date","getTime","hooks","make","tapAsync","mainCompilation","callback","previousEntries","previousResult","isCacheValidPromise","isCacheValid","cachedResult","then","compiledEntriesPromise","compileEntries","childCompilationResult","createSnapshot","snapshot","optimizeTree","chunks","modules","handleCompilationDonePromise","watchFiles","additionalAssets","didRecompilePromise","all","didRecompile","hash","indexOf","reject","length","isSnapShotValid","compileTemplates","result","files","module","exports"],"sources":["/Users/Chloe/Desktop/CS1300/UI-Portfolio/node_modules/html-webpack-plugin/lib/cached-child-compiler.js"],"sourcesContent":["// @ts-check\n/**\n * @file\n * Helper plugin manages the cached state of the child compilation\n *\n * To optimize performance the child compilation is running asyncronously.\n * Therefore it needs to be started in the compiler.make phase and ends after\n * the compilation.afterCompile phase.\n *\n * To prevent bugs from blocked hooks there is no promise or event based api\n * for this plugin.\n *\n * Example usage:\n *\n * ```js\n    const childCompilerPlugin = new PersistentChildCompilerPlugin();\n    childCompilerPlugin.addEntry('./src/index.js');\n    compiler.hooks.afterCompile.tapAsync('MyPlugin', (compilation, callback) => {\n      console.log(childCompilerPlugin.getCompilationResult()['./src/index.js']));\n      return true;\n    });\n * ```\n */\n\n// Import types\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n/** @typedef {{hash: string, entry: any, content: string }} ChildCompilationResultEntry */\n/** @typedef {import(\"./file-watcher-api\").Snapshot} Snapshot */\n/** @typedef {{fileDependencies: string[], contextDependencies: string[], missingDependencies: string[]}} FileDependencies */\n/** @typedef {{\n  dependencies: FileDependencies,\n  compiledEntries: {[entryName: string]: ChildCompilationResultEntry}\n} | {\n  dependencies: FileDependencies,\n  error: Error\n}} ChildCompilationResult */\n'use strict';\n\nconst { HtmlWebpackChildCompiler } = require('./child-compiler');\nconst fileWatcherApi = require('./file-watcher-api');\n\n/**\n * This plugin is a singleton for performance reasons.\n * To keep track if a plugin does already exist for the compiler they are cached\n * in this map\n * @type {WeakMap<WebpackCompiler, PersistentChildCompilerSingletonPlugin>}}\n */\nconst compilerMap = new WeakMap();\n\nclass CachedChildCompilation {\n  /**\n   * @param {WebpackCompiler} compiler\n   */\n  constructor (compiler) {\n    /**\n     * @private\n     * @type {WebpackCompiler}\n     */\n    this.compiler = compiler;\n    // Create a singleton instance for the compiler\n    // if there is none\n    if (compilerMap.has(compiler)) {\n      return;\n    }\n    const persistentChildCompilerSingletonPlugin = new PersistentChildCompilerSingletonPlugin();\n    compilerMap.set(compiler, persistentChildCompilerSingletonPlugin);\n    persistentChildCompilerSingletonPlugin.apply(compiler);\n  }\n\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {string} entry\n   */\n  addEntry (entry) {\n    const persistentChildCompilerSingletonPlugin = compilerMap.get(this.compiler);\n    if (!persistentChildCompilerSingletonPlugin) {\n      throw new Error(\n        'PersistentChildCompilerSingletonPlugin instance not found.'\n      );\n    }\n    persistentChildCompilerSingletonPlugin.addEntry(entry);\n  }\n\n  getCompilationResult () {\n    const persistentChildCompilerSingletonPlugin = compilerMap.get(this.compiler);\n    if (!persistentChildCompilerSingletonPlugin) {\n      throw new Error(\n        'PersistentChildCompilerSingletonPlugin instance not found.'\n      );\n    }\n    return persistentChildCompilerSingletonPlugin.getLatestResult();\n  }\n\n  /**\n   * Returns the result for the given entry\n   * @param {string} entry\n   * @returns {\n      | { mainCompilationHash: string, error: Error }\n      | { mainCompilationHash: string, compiledEntry: ChildCompilationResultEntry }\n    }\n   */\n  getCompilationEntryResult (entry) {\n    const latestResult = this.getCompilationResult();\n    const compilationResult = latestResult.compilationResult;\n    return 'error' in compilationResult ? {\n      mainCompilationHash: latestResult.mainCompilationHash,\n      error: compilationResult.error\n    } : {\n      mainCompilationHash: latestResult.mainCompilationHash,\n      compiledEntry: compilationResult.compiledEntries[entry]\n    };\n  }\n}\n\nclass PersistentChildCompilerSingletonPlugin {\n  constructor () {\n    /**\n     * @private\n     * @type {\n      | {\n        isCompiling: false,\n        isVerifyingCache: false,\n        entries: string[],\n        compiledEntries: string[],\n        mainCompilationHash: string,\n        compilationResult: ChildCompilationResult\n      }\n    | Readonly<{\n      isCompiling: false,\n      isVerifyingCache: true,\n      entries: string[],\n      previousEntries: string[],\n      previousResult: ChildCompilationResult\n    }>\n    | Readonly <{\n      isVerifyingCache: false,\n      isCompiling: true,\n      entries: string[],\n    }>\n  } the internal compilation state */\n    this.compilationState = {\n      isCompiling: false,\n      isVerifyingCache: false,\n      entries: [],\n      compiledEntries: [],\n      mainCompilationHash: 'initial',\n      compilationResult: {\n        dependencies: {\n          fileDependencies: [],\n          contextDependencies: [],\n          missingDependencies: []\n        },\n        compiledEntries: {}\n      }\n    };\n  }\n\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {WebpackCompiler} compiler\n   */\n  apply (compiler) {\n    /** @type Promise<ChildCompilationResult> */\n    let childCompilationResultPromise = Promise.resolve({\n      dependencies: {\n        fileDependencies: [],\n        contextDependencies: [],\n        missingDependencies: []\n      },\n      compiledEntries: {}\n    });\n    /**\n     * The main compilation hash which will only be updated\n     * if the childCompiler changes\n     */\n    let mainCompilationHashOfLastChildRecompile = '';\n    /** @typedef{Snapshot|undefined} */\n    let previousFileSystemSnapshot;\n    let compilationStartTime = new Date().getTime();\n\n    compiler.hooks.make.tapAsync(\n      'PersistentChildCompilerSingletonPlugin',\n      (mainCompilation, callback) => {\n        if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n          return callback(new Error('Child compilation has already started'));\n        }\n\n        // Update the time to the current compile start time\n        compilationStartTime = new Date().getTime();\n\n        // The compilation starts - adding new templates is now not possible anymore\n        this.compilationState = {\n          isCompiling: false,\n          isVerifyingCache: true,\n          previousEntries: this.compilationState.compiledEntries,\n          previousResult: this.compilationState.compilationResult,\n          entries: this.compilationState.entries\n        };\n\n        // Validate cache:\n        const isCacheValidPromise = this.isCacheValid(previousFileSystemSnapshot, mainCompilation);\n\n        let cachedResult = childCompilationResultPromise;\n        childCompilationResultPromise = isCacheValidPromise.then((isCacheValid) => {\n          // Reuse cache\n          if (isCacheValid) {\n            return cachedResult;\n          }\n          // Start the compilation\n          const compiledEntriesPromise = this.compileEntries(\n            mainCompilation,\n            this.compilationState.entries\n          );\n          // Update snapshot as soon as we know the filedependencies\n          // this might possibly cause bugs if files were changed inbetween\n          // compilation start and snapshot creation\n          compiledEntriesPromise.then((childCompilationResult) => {\n            return fileWatcherApi.createSnapshot(childCompilationResult.dependencies, mainCompilation, compilationStartTime);\n          }).then((snapshot) => {\n            previousFileSystemSnapshot = snapshot;\n          });\n          return compiledEntriesPromise;\n        });\n\n        // Add files to compilation which needs to be watched:\n        mainCompilation.hooks.optimizeTree.tapAsync(\n          'PersistentChildCompilerSingletonPlugin',\n          (chunks, modules, callback) => {\n            const handleCompilationDonePromise = childCompilationResultPromise.then(\n              childCompilationResult => {\n                this.watchFiles(\n                  mainCompilation,\n                  childCompilationResult.dependencies\n                );\n              });\n            handleCompilationDonePromise.then(() => callback(null, chunks, modules), callback);\n          }\n        );\n\n        // Store the final compilation once the main compilation hash is known\n        mainCompilation.hooks.additionalAssets.tapAsync(\n          'PersistentChildCompilerSingletonPlugin',\n          (callback) => {\n            const didRecompilePromise = Promise.all([childCompilationResultPromise, cachedResult]).then(\n              ([childCompilationResult, cachedResult]) => {\n                // Update if childCompilation changed\n                return (cachedResult !== childCompilationResult);\n              }\n            );\n\n            const handleCompilationDonePromise = Promise.all([childCompilationResultPromise, didRecompilePromise]).then(\n              ([childCompilationResult, didRecompile]) => {\n                // Update hash and snapshot if childCompilation changed\n                if (didRecompile) {\n                  mainCompilationHashOfLastChildRecompile = mainCompilation.hash;\n                }\n                this.compilationState = {\n                  isCompiling: false,\n                  isVerifyingCache: false,\n                  entries: this.compilationState.entries,\n                  compiledEntries: this.compilationState.entries,\n                  compilationResult: childCompilationResult,\n                  mainCompilationHash: mainCompilationHashOfLastChildRecompile\n                };\n              });\n            handleCompilationDonePromise.then(() => callback(null), callback);\n          }\n        );\n\n        // Continue compilation:\n        callback(null);\n      }\n    );\n  }\n\n  /**\n   * Add a new entry to the next compile run\n   * @param {string} entry\n   */\n  addEntry (entry) {\n    if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n      throw new Error(\n        'The child compiler has already started to compile. ' +\n        \"Please add entries before the main compiler 'make' phase has started or \" +\n        'after the compilation is done.'\n      );\n    }\n    if (this.compilationState.entries.indexOf(entry) === -1) {\n      this.compilationState.entries = [...this.compilationState.entries, entry];\n    }\n  }\n\n  getLatestResult () {\n    if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n      throw new Error(\n        'The child compiler is not done compiling. ' +\n        \"Please access the result after the compiler 'make' phase has started or \" +\n        'after the compilation is done.'\n      );\n    }\n    return {\n      mainCompilationHash: this.compilationState.mainCompilationHash,\n      compilationResult: this.compilationState.compilationResult\n    };\n  }\n\n  /**\n   * Verify that the cache is still valid\n   * @private\n   * @param {Snapshot | undefined} snapshot\n   * @param {WebpackCompilation} mainCompilation\n   * @returns {Promise<boolean>}\n   */\n  isCacheValid (snapshot, mainCompilation) {\n    if (!this.compilationState.isVerifyingCache) {\n      return Promise.reject(new Error('Cache validation can only be done right before the compilation starts'));\n    }\n    // If there are no entries we don't need a new child compilation\n    if (this.compilationState.entries.length === 0) {\n      return Promise.resolve(true);\n    }\n    // If there are new entries the cache is invalid\n    if (this.compilationState.entries !== this.compilationState.previousEntries) {\n      return Promise.resolve(false);\n    }\n    // Mark the cache as invalid if there is no snapshot\n    if (!snapshot) {\n      return Promise.resolve(false);\n    }\n    return fileWatcherApi.isSnapShotValid(snapshot, mainCompilation);\n  }\n\n  /**\n   * Start to compile all templates\n   *\n   * @private\n   * @param {WebpackCompilation} mainCompilation\n   * @param {string[]} entries\n   * @returns {Promise<ChildCompilationResult>}\n   */\n  compileEntries (mainCompilation, entries) {\n    const compiler = new HtmlWebpackChildCompiler(entries);\n    return compiler.compileTemplates(mainCompilation).then((result) => {\n      return {\n      // The compiled sources to render the content\n        compiledEntries: result,\n        // The file dependencies to find out if a\n        // recompilation is required\n        dependencies: compiler.fileDependencies,\n        // The main compilation hash can be used to find out\n        // if this compilation was done during the current compilation\n        mainCompilationHash: mainCompilation.hash\n      };\n    }, error => ({\n      // The compiled sources to render the content\n      error,\n      // The file dependencies to find out if a\n      // recompilation is required\n      dependencies: compiler.fileDependencies,\n      // The main compilation hash can be used to find out\n      // if this compilation was done during the current compilation\n      mainCompilationHash: mainCompilation.hash\n    }));\n  }\n\n  /**\n   * @private\n   * @param {WebpackCompilation} mainCompilation\n   * @param {FileDependencies} files\n   */\n  watchFiles (mainCompilation, files) {\n    fileWatcherApi.watchFiles(mainCompilation, files);\n  }\n}\n\nmodule.exports = {\n  CachedChildCompilation\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}