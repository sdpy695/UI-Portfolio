{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;\nvar boolbase_1 = require(\"boolbase\");\nvar procedure_1 = require(\"../procedure\");\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexports.PLACEHOLDER_ELEMENT = {};\nfunction ensureIsTag(next, adapter) {\n  if (next === boolbase_1.falseFunc) return boolbase_1.falseFunc;\n  return function (elem) {\n    return adapter.isTag(elem) && next(elem);\n  };\n}\nexports.ensureIsTag = ensureIsTag;\nfunction getNextSiblings(elem, adapter) {\n  var siblings = adapter.getSiblings(elem);\n  if (siblings.length <= 1) return [];\n  var elemIndex = siblings.indexOf(elem);\n  if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];\n  return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nexports.getNextSiblings = getNextSiblings;\nvar is = function (next, token, options, context, compileToken) {\n  var opts = {\n    xmlMode: !!options.xmlMode,\n    adapter: options.adapter,\n    equals: options.equals\n  };\n  var func = compileToken(token, opts, context);\n  return function (elem) {\n    return func(elem) && next(elem);\n  };\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexports.subselects = {\n  is: is,\n  /**\n   * `:matches` and `:where` are aliases for `:is`.\n   */\n  matches: is,\n  where: is,\n  not: function (next, token, options, context, compileToken) {\n    var opts = {\n      xmlMode: !!options.xmlMode,\n      adapter: options.adapter,\n      equals: options.equals\n    };\n    var func = compileToken(token, opts, context);\n    if (func === boolbase_1.falseFunc) return next;\n    if (func === boolbase_1.trueFunc) return boolbase_1.falseFunc;\n    return function not(elem) {\n      return !func(elem) && next(elem);\n    };\n  },\n  has: function (next, subselect, options, _context, compileToken) {\n    var adapter = options.adapter;\n    var opts = {\n      xmlMode: !!options.xmlMode,\n      adapter: adapter,\n      equals: options.equals\n    };\n    // @ts-expect-error Uses an array as a pointer to the current element (side effects)\n    var context = subselect.some(function (s) {\n      return s.some(procedure_1.isTraversal);\n    }) ? [exports.PLACEHOLDER_ELEMENT] : undefined;\n    var compiled = compileToken(subselect, opts, context);\n    if (compiled === boolbase_1.falseFunc) return boolbase_1.falseFunc;\n    if (compiled === boolbase_1.trueFunc) {\n      return function (elem) {\n        return adapter.getChildren(elem).some(adapter.isTag) && next(elem);\n      };\n    }\n    var hasElement = ensureIsTag(compiled, adapter);\n    var _a = compiled.shouldTestNextSiblings,\n      shouldTestNextSiblings = _a === void 0 ? false : _a;\n    /*\n     * `shouldTestNextSiblings` will only be true if the query starts with\n     * a traversal (sibling or adjacent). That means we will always have a context.\n     */\n    if (context) {\n      return function (elem) {\n        context[0] = elem;\n        var childs = adapter.getChildren(elem);\n        var nextElements = shouldTestNextSiblings ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;\n        return next(elem) && adapter.existsOne(hasElement, nextElements);\n      };\n    }\n    return function (elem) {\n      return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));\n    };\n  }\n};","map":{"version":3,"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","Object","defineProperty","exports","value","subselects","getNextSiblings","ensureIsTag","PLACEHOLDER_ELEMENT","boolbase_1","require","procedure_1","next","adapter","falseFunc","elem","isTag","siblings","getSiblings","elemIndex","indexOf","filter","is","token","options","context","compileToken","opts","xmlMode","equals","func","matches","where","not","trueFunc","has","subselect","_context","some","s","isTraversal","undefined","compiled","getChildren","hasElement","_a","shouldTestNextSiblings","childs","nextElements","existsOne"],"sources":["/Users/Chloe/Desktop/CS1300/UI-Portfolio/node_modules/css-select/lib/pseudo-selectors/subselects.js"],"sourcesContent":["\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;\nvar boolbase_1 = require(\"boolbase\");\nvar procedure_1 = require(\"../procedure\");\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexports.PLACEHOLDER_ELEMENT = {};\nfunction ensureIsTag(next, adapter) {\n    if (next === boolbase_1.falseFunc)\n        return boolbase_1.falseFunc;\n    return function (elem) { return adapter.isTag(elem) && next(elem); };\n}\nexports.ensureIsTag = ensureIsTag;\nfunction getNextSiblings(elem, adapter) {\n    var siblings = adapter.getSiblings(elem);\n    if (siblings.length <= 1)\n        return [];\n    var elemIndex = siblings.indexOf(elem);\n    if (elemIndex < 0 || elemIndex === siblings.length - 1)\n        return [];\n    return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nexports.getNextSiblings = getNextSiblings;\nvar is = function (next, token, options, context, compileToken) {\n    var opts = {\n        xmlMode: !!options.xmlMode,\n        adapter: options.adapter,\n        equals: options.equals,\n    };\n    var func = compileToken(token, opts, context);\n    return function (elem) { return func(elem) && next(elem); };\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexports.subselects = {\n    is: is,\n    /**\n     * `:matches` and `:where` are aliases for `:is`.\n     */\n    matches: is,\n    where: is,\n    not: function (next, token, options, context, compileToken) {\n        var opts = {\n            xmlMode: !!options.xmlMode,\n            adapter: options.adapter,\n            equals: options.equals,\n        };\n        var func = compileToken(token, opts, context);\n        if (func === boolbase_1.falseFunc)\n            return next;\n        if (func === boolbase_1.trueFunc)\n            return boolbase_1.falseFunc;\n        return function not(elem) {\n            return !func(elem) && next(elem);\n        };\n    },\n    has: function (next, subselect, options, _context, compileToken) {\n        var adapter = options.adapter;\n        var opts = {\n            xmlMode: !!options.xmlMode,\n            adapter: adapter,\n            equals: options.equals,\n        };\n        // @ts-expect-error Uses an array as a pointer to the current element (side effects)\n        var context = subselect.some(function (s) {\n            return s.some(procedure_1.isTraversal);\n        })\n            ? [exports.PLACEHOLDER_ELEMENT]\n            : undefined;\n        var compiled = compileToken(subselect, opts, context);\n        if (compiled === boolbase_1.falseFunc)\n            return boolbase_1.falseFunc;\n        if (compiled === boolbase_1.trueFunc) {\n            return function (elem) {\n                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);\n            };\n        }\n        var hasElement = ensureIsTag(compiled, adapter);\n        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;\n        /*\n         * `shouldTestNextSiblings` will only be true if the query starts with\n         * a traversal (sibling or adjacent). That means we will always have a context.\n         */\n        if (context) {\n            return function (elem) {\n                context[0] = elem;\n                var childs = adapter.getChildren(elem);\n                var nextElements = shouldTestNextSiblings\n                    ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;\n                return (next(elem) && adapter.existsOne(hasElement, nextElements));\n            };\n        }\n        return function (elem) {\n            return next(elem) &&\n                adapter.existsOne(hasElement, adapter.getChildren(elem));\n        };\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}